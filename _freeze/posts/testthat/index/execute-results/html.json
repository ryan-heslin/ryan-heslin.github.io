{
  "hash": "fd6ce4873731794b05c15dbeddb34d76",
  "result": {
    "markdown": "---\ntitle: \"Don't Neglect Unit Testing\"\nauthor: \"Ryan Heslin\"\ndate: \"2022-07-19\"\ncategories: [\"R\"]\nparams:\n    title: \"Don't Neglect Unit Testing\"\n---\n\n\nBad habits are hard to break. When I finish a first version of a function, I sometimes just make up\nan input, call it interactively, and move on if it seems to work, promising myself I'll\nget around to properly testing it later. If someone asks me about it,\nI can only reply honestly: \"I haven't tested it thoroughly, but I'm pretty sure\nit works.\" I do use and appreciate unit testing: when I wrote my first package,\nI tested it thoroughly, probably too thoroughly. Still, I often yield to the\ntemptation of informal testing, and just as often regret it.\n\nI relearned this lesson recently while writing tests for the image classifier\nI've been working on for several months. It uses the `torch` package, which\ncontains R bindings for the `torch` machine learning library. The classifier uses a\ncustomized subclass of a class called `torch_dataset` to implement a pretrained neural network.\n`torch_dataset` instances organize data for model training and\nevaluation. The subclass, called `candidate_image_dataset`, does this with file paths\nto images and class labels. Sampling an instance\ndirectly creates a tensor containing that image's data; it also exposes an\nattributed called `metadata`, a data frame with each image's file path and class\nlabel. The subclass can also be configured to return a randomly selected image\nwhen indexed. But if sampling is disabled, indexing the $i$th image\ndirectly should yield the image found in row $i$ of `metadata`.\n\nAlmost as an afterthought, I added a test of the subclass' `.getitem` method to confirm all this\nworked as described\nAll it did was check that, for an instance $x$ that did not use sampling,\n`x$getitem(1)` returned the image whose file path was stored in `x$metadata[1,]`.\n\nI tend to be pessimistic,\nbut I was still caught off guard when this trivial check failed.\nUnnerved, I looked through my code for the origin of the bug. The logical flag\ncontrolling whether an instance sampled indices did check whether the user had specified\nsampling weights, as expected:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nif (n_weights != 0) {\n  private$.sample_weights <- self$compute_sample_weights(\n    images,\n    sample_weights\n  )\n  private$.uses_sample <- TRUE\n}\n```\n:::\n\n\nThat left only one possible culprit: a wrongly set default value. Sure enough,\nin the list of private attributes:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nprivate$.uses_sample <- TRUE\n```\n:::\n\n\nSo the class was sampling whether the user indicated it or not. I changed that `TRUE`\nto `FALSE` and the test passed.\nHad I not taken a few minutes to construct this seemingly unnecessary unit test,\nI would not have noticed the bug. I would only have caught it at a less convenient\ntime, possibly after it compromised results obtained from the classifier. Verifying the assumptions you make about\nyour code, even obvious ones, is never wasted time.\n\nUnit testing, at least for me, has another advantage: it's tremendously motivating.\nWhen the console fills up with a traceback and a cryptic error message, I know\nI made a mistake somewhere. That makes me responsible for correcting it. I become\nvery dogged when I have a clear goal in mind, so I seldom fail to track down\nand fix the bug. Pinning down the cause holds some interest, too, since it's typically\na surprise: anything from a misnamed variable to a subtle misunderstanding that compromises\nthe whole algorithm.\n\nThen, having hopefully learned my lesson, it's on to the next test case.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}