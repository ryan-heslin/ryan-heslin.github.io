{
  "hash": "9d886a51b606c637b8726b43fdf1024c",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code 2023 Day 10\"\ndate: \"13-12-2023\"\n# freeze computational output\n# (see https://quarto.org/docs/projects/code-execution.html#freeze)\nfreeze: auto\n---\n\nAfter a few days' delay, I've finally solved this vexing puzzle. \nYou are given a large grid strewn with characters - `-`, `|`, `J`, `F`, `7`, and `L` - \nthat represent pieces of pipe that point in different directions. The pipe contains \na large loop that starts at a given point. Part 1 simply asks for the size of the loop. \n\nPart 2 \"reveals\" that you actually want to find the area enclosed by the pipe loop, \nincluding disconnected pipe pieces lying around. Just one problem: it's possible \nto squeeze _between_ pipes, (e.g., two parallel lines of pipe) meaning an area completely surrounded by pipe tiles \nmight be accessible. \n\nI struggled to deal with this before finding the obvious solution: convert each\ngrid square into nine, so squeezing between pipes can be directly modeled.\nThen use flood-fill to find all coordinates enclosed by the grid, convert them \nback to the original coordinates by integer-dividing by 3, then count them.\n\nAfter more debugging than I would like, I got it right:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef flood_fill(grid, xmin, xmax, ymin, ymax, get_neighbors, traversed):\n    exposed = set()\n    enclosed = set()\n    for coord, el in grid.items():\n        if (el and downscale(el, 3) not in traversed) or (coord in enclosed or coord in exposed):\n            continue\n        queue = deque()\n        queue.append(coord)\n        visited = set()\n        open = False\n\n        while queue:\n            new = queue.pop()\n            visited.add(new)\n            open = open or (\n                new in exposed\n                or (\n                    new.real == xmin\n                    or new.real == xmax\n                    or new.imag == ymin\n                    or new.imag == ymax\n                )\n            )\n            new_neighbors = get_neighbors(new)\n\n            for neighbor in new_neighbors:\n                # if neighbor in exposed:\n                #     open = True\n                if not ((grid[neighbor] and downscale(neighbor, 3) in traversed) or neighbor in visited):\n                    queue.append(neighbor)\n        if open:\n            exposed.update(visited)\n        else:\n            enclosed.update(visited)\n    return enclosed\n\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}