{
  "hash": "5a60c538350e0b995592511df57fadf5",
  "result": {
    "markdown": "---\ntitle: \"Lexical Scope: Who Does It Best?\"\nauthor: \"Ryan Heslin\"\ndate: \"2023-01-18\"\ncategories: \nurlcolor: \"blue\"\n---\n\n\n\n\n# Introduction\n\nMost programming languages have some notion of scope: a frame of names bound to values.\nA program will involve many interlocking scopes, all associated with \nconstructs like functions and (in some languages) blocks.\nEach language has its own rules for managing\nscope. These rules determine how references to variable names are resolved at runtime. They typically organize scopes into\na hierarchy and determine which scope \"wins\"\nwhen the same name exists in multiple\nscopes visible at a given time.\nAn important part of scoping rules is what happens when a name is looked up in a scope where it is not bound to any object. As we will see, different languages have different \nways of handling this case. \n\nA common pattern is called _lexical scope_.\nThis means that objects, particularly functions, consider their parent scope to be\nthe scope where they were defined. In a lexically scoped language,\nif a function can't find an object called\n`x` in its execution environment, \nthe interpreter or compiler would look next\nin whichever environment the function was\ndefined in (often called the enclosing environment). This behavior has the\nadvantage of consistency, since a given function's enclosing environment is the same\nno matter where the function is called.\n\nLanguages with lexical scope often allow\nassignments in a function's enclosing environment.\nIf a function is defined in the global environment, this is usually bad idea,\nsince it violates the principle that functions should avoid unnecessary side\neffects. But side effects are no issue if that enclosing environment is\n_another_ function's execution environment. Suppose `f` is a function that returns a function\n`g` when called. `g`'s enclosing environment, the place it was defined,  is `f`'s execution environment. So any binding `g`\nmakes in its enclosing environment when it is called is\nvisible _only_ to subsequent calls to `g`!\nThis fact makes it possible for functions\nto read and write a private cache, enabling a host of powerful programming techniques.\n\nThis post compares the syntax several languages use for assignments in enclosing \nscope. We'll implement a common pattern in each and contrast the \nlanguages' very different means of supporting the same basic idea.\n\nThat pattern is called [memoization](https://en.wikipedia.org/wiki/Memoization).\nIt can be used to write functions that \"remember\" their result for a given\ninput after computing it the first time. This approach trades performance for\nmemory; used well, it can speed up code by saving the results of expensive \ncomputations instead of repeating them.\n\nWe'll compare how several popular languages approach lexical scope using a simple application called `neighbors`.\n`neighbors` is a function that returns a memoized function that finds the\nfour non-diagonal neighbors of a point\non a two-dimensional [Cartesian](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) grid.\nEach time this function is called on a new point, it computes that point's neighbors and stores them in an associative data structure in its enclosing environment. Subsequent\ncalls with the same argument find the cached value and return it, preventing repeated computation. While trivial, this technique\nmight be useful on certain [Advent of Code](https://adventofcode.com) problems, where\nit might be necessary to check a point's neighbors many times.\n\nFor simplicity, I make no attempt to verify that inputs as two-dimensional coordinates,\nwhich a real implementation would have to do.\n\n# Python\n\nWe may as well start with good old Python.\nOne of Python's core design principles is\n\"explicit is better than implicit.\" So it is with lexical scope. If you want to\nmodify a variable in the global environment from within a function (which you probably shouldn't),\nyou have to use the `global` keyword:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .source .cell-code}\nx = 5\n\ndef modify():\n    global x\n    x = 6\nmodify()\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- 6\n```\n:::\n:::\n\n\n\nThere is a different keyword, `nonlocal`, that should be used when the enclosing environemnt\nis a function's evaluation environment.\nHere is `neighbors` in Python:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .source .cell-code}\ndef neighbors():\n    memo = {}\n    def inner(x):\n        nonlocal memo\n        if x not in memo.keys():\n            memo[x] = ((x[0] - 1, x[1]),\n            (x[0] + 1, x[1]),\n            (x[0], x[1] - 1),\n            (x[0], x[1] + 1))\n        return memo[x]\n    return inner\n\nget_neighbors = neighbors()\nget_neighbors((2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- ((1, 3), (3, 3), (2, 2), (2, 4))\n```\n:::\n\n```{.python .source .cell-code}\nget_neighbors((1, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- ((0, 4), (2, 4), (1, 3), (1, 5))\n```\n:::\n\n```{.python .source .cell-code}\nget_neighbors((2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- ((1, 3), (3, 3), (2, 2), (2, 4))\n```\n:::\n:::\n\n\nThis implementation shows off one of my favorite Python features: any immutable\nobject can serve as a dict key, not just strings. We can just \nuse coordinates as indices.\nThe use of keywords makes it impossible to use global data unless you really want to, but\nit's hardly elegant.\n\nI could have avoided most of the work above by just writing a function to\ncompute neighbors and adding the `cache` decorator from the `functools` module.\n(In Python, decorators are functions that modify other functions. A special syntax\nexists for applying them). That would have memoized the function automatically.\nBut I think it's instructive to demonstrate the concept in pure Python.\n\n# Bash\n\nSpeaking of elegance, we'll now consider a language about as elegant\nas an [A-10](https://en.wikipedia.org/wiki/Fairchild_Republic_A-10_Thunderbolt_II): Bash.\nBash is designed for interactively managing\nfilesystems and operating systems, or\nwriting scripts that do the same thing.\nIts syntax isn't pretty, but it's brutally\neffective in its role.\n\nBut this pattern can't be implemented in Bash, so far as I know.\nBash is dynamically scoped, not lexically scoped. That means\na function that fails to find a variable in its local scope will next look in its\n_caller_'s scope, then the caller's caller's scope, and so on, instead of the scope\nwhere it was defined. If we tried to implement a Python-style `neighbors` in\nBash like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.sh .source .cell-code}\n\nneighbors(){\n    declare -A memo\n    local code='get_neighbors(){\n    local x=\"$1\"\n    local y=\"$2\"\n    local hash = \"$x,$y\"\n\n    if [ ! -v memo[\"$hash\"] ]; then\n        local west=\"$(($x-1)),$y\"\n        local east=\"$(($x+1)),$y\"\n        local south=\"$x,$(($y -1))\"\n        local north=\"$x,$(($y +1))\"\n        memo+=([\"$hash\"]=\"$north-$east-$south-$west\")\n    fi\n}'\nexec \"$code\"\n}\n```\n:::\n\nthe function it returned (to be exact, the function generated by the code string it evaluated ) would not \"remember\" the `memo` array, because\nbindings in the scope where the array was defined would not be preserved.\nEven if we ignore that fact,  Bash is a bad choice for this problem because it doesn't support\nmultidimensional arrays, so I had to resort to some ugly code to represent the coordinates\nas a string. Bash is indispensable in many situations, but not this one.\n\n# Lua\n\nLua is a fast, lightweight scripting language. Though its design is minimalist,\nwith simple syntax and few data structures,\nit does support lexical scope, enabling the\nusual functional programming tricks.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.lua .source .cell-code}\npresent_table = function(x)\n    result = {}\n    for i, tab in ipairs(x) do\n        result[i] = \"{\" .. table.concat(tab, \", \") .. \"}\"\n    end\n    return \"{\" .. table.concat(result, \", \") .. \"}\"\nend\n\nneighbors = function()\n    local memo = {}\n    return function(x)\n        local hash = table.concat(x, \",\")\n        if memo[hash] == nil then\n            memo[hash] = {\n                { x[1] - 1, x[2] },\n                { x[1] + 1, x[2] },\n                { x[1], x[2] - 1 },\n                { x[1], x[2] + 1 },\n            }\n        end\n        return memo[hash]\n    end\nend\n\nget_neighbors = neighbors()\nprint(present_table(get_neighbors({ 2, 3 })))\nprint(present_table(get_neighbors({ 1, 4 })))\nprint(present_table(get_neighbors({ 2, 3 })))\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- {{1, 3}, {3, 3}, {2, 2}, {2, 4}}\n-- {{0, 4}, {2, 4}, {1, 3}, {1, 5}}\n-- {{1, 3}, {3, 3}, {2, 2}, {2, 4}}\n```\n:::\n:::\n\n\nLua automatically finds the `memo` table (what Lua calls its all-purpose record data structure) in the\nenclosing scope and modifies it. I had to write my own function to print tables, however, because Lua only prints a table's memory address by default. The only other\nwrinkle is that Lua makes variables global _by default_. You have to use the `local` keyword to bind variables\nin a function's execution scope (or make them local to a script). Since\ncreating global variables from functions\nis usually a bad idea, I think it should be the other way around, as in Python, but that's a\nmatter of preference.\n\nThis snippet demonstrates another neat feature of Lua: looking up a nonexistent table\nindex or unbound variable returns `nil` instead of an error, making it safe to\ntest for index existence.\n\n# JavaScript\n\nLike Bash, JavaScript is respected\nfor its usefulness and ubiquity rather than its\n    elegance. Say what you will about JavaScript's\nloose typing, design inconsistencies, and erratic syntax,\nit isn't Python that powers the modern Web.\n\nAs in Lua, there's no need to use special\nsyntax to write in the enclosing\nscope. But I do have to use JavaScript's declaration keywords, which have characteristically intricate rules. I need to use `let` inside the function instead of `const` to avoid creating global variables; `var` has yet another assignment behavior. Still, it's easy enough\nto express the functional idiom:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.js .source .cell-code}\nfunction neighbors(){\n    let memo = {};\n\n    return function(x){\n        let hash = x.toString();\n        if(!(hash in memo)){\n            memo[hash] = [[x[0] -1, x[1]],\n            [x[0] + 1, x[1]],\n            [x[0], x[1] - 1],\n            [x[0], x[1] + 1]];\n        }\n        return memo[hash];\n    }\n}\nconst get_neighbors = neighbors();\nconsole.log(get_neighbors([ 2, 3 ]));\nconsole.log(get_neighbors([ 1, 4 ]));\nconsole.log(get_neighbors([ 2, 3 ]));\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [ [ 1, 3 ], [ 3, 3 ], [ 2, 2 ], [ 2, 4 ] ]\n-- [ [ 0, 4 ], [ 2, 4 ], [ 1, 3 ], [ 1, 5 ] ]\n-- [ [ 1, 3 ], [ 3, 3 ], [ 2, 2 ], [ 2, 4 ] ]\n```\n:::\n:::\n\n\n# SQL\n\nSurprisingly, SQL provides\nthe most elegant interface for functional\nprogramming. Strange as it sounds, its\nexpressive, if finicky, declarative syntax\nenables powerful idioms. With creative use of `GROUP BY`\nclauses and certain window functions, it\nis possible to -\n\nJust kidding. But it probably is possible,\nalbeit silly,\nto implement `neighbors` in procedural\nSQL.\n\n# R\n\nAs in many things, I'm biased toward R because it was my first language. But\nI think R wins this comparison on the merits.\n\nR has the most elegant solution to writing in the enclosing environment.\nThe regular assignment operator, `<-`, only ever binds in its caller environment\n(and yes, it technically is a function, so it's correct to speak of its caller environment). Instead, R implements assignment in enclosing\nenvironments using a _super_assignment\noperator, `<<-`. (In R, environments are first-class objects that record their parent\nenvironments). This operator checks the\nparent of the caller environment for a binding with the same name as the one being used, and overwrites that binding if it exists.\nIf the name is not bound in the parent environment, it repeats this process for each\nparent of that environment, and finally binds the name in the global environment if it is\nnot defined anywhere.\n\nThis power can be used for evil, as in this snippet that modifies a global variable:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nf1 <- function() {\n  x <<- 5\n}\nf1()\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [1] 5\n```\n:::\n:::\n\n\nOr for good, as in this version of `neighbors`.\nIt works because closures, the type R uses to implement most functions, record the environment\nwhere they were defined.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nneighbors <- function() {\n  memo <- new.env(hash = TRUE)\n  function(x) {\n    hash <- paste(as.character(x), collapse = \"\")\n    result <- tryCatch(get(hash, memo), error = function(e) {\n      result <- list(\n        c(x[[1]] - 1, x[[2]]),\n        c(x[[1]] + 1, x[[2]]),\n        c(x[[1]], x[[2]] - 1),\n        c(x[[1]], x[[2]] + 1)\n      )\n      memo[[hash]] <<- result\n      result\n    })\n    result\n  }\n}\nget_neighbors <- neighbors()\nget_neighbors(c(2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [[1]]\n-- [1] 1 3\n-- \n-- [[2]]\n-- [1] 3 3\n-- \n-- [[3]]\n-- [1] 2 2\n-- \n-- [[4]]\n-- [1] 2 4\n```\n:::\n\n```{.r .source .cell-code}\nget_neighbors(c(1, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [[1]]\n-- [1] 0 4\n-- \n-- [[2]]\n-- [1] 2 4\n-- \n-- [[3]]\n-- [1] 1 3\n-- \n-- [[4]]\n-- [1] 1 5\n```\n:::\n\n```{.r .source .cell-code}\nget_neighbors(c(2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [[1]]\n-- [1] 1 3\n-- \n-- [[2]]\n-- [1] 3 3\n-- \n-- [[3]]\n-- [1] 2 2\n-- \n-- [[4]]\n-- [1] 2 4\n```\n:::\n:::\n\n\nNotice how `<<-` still works correctly,\neven embedded in an anonymous function passed as\nan error handler to `tryCatch`. The one\nannoyance is that numeric vectors can't\nbe used as names.\n\n# Conclusion\n\nAt the end of the day, broad techniques like memoization transcend any individual language.\nAll the languages above (except Bash) make it relatively easy to use memoization.\nAs with most programming concepts, translating the principles into any given\nlanguage is much easier than understanding them in the first place. Still,\nthe comparison here highlighted each language's character: Python's explicitness,\nLua's simplicity, and R's lovable blend of elegance and jankiness.\n(Also worth noting: the languages featured each call their associative\ndata structure something different).\n\nI like R's approach best. A special version of the assignment operator clearly\nsignals that something unusual is being done, and it is visually distinct yet\nhard to type by accident. (RStudio, the premier R IDE, has a keyboard shortcut\nfor `<-` that makes mistakenly typing `<<-` very unlikely). But which is\nyour favorite?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}