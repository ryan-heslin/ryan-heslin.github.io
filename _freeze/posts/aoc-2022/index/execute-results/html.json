{
  "hash": "e801cc4f6035a1d91fb5c6540839315e",
  "result": {
    "markdown": "---\ntitle: \"Reflections on Advent of Code 2022\"\nauthor: \"Ryan Heslin\"\ndate: \"2022-12-31\"\ncategories: [\"R\"]\nurlcolor: \"blue\"\n---\n\n\n# Overview\n\n[Advent of Code 2022](https://adventofcode.com/2022) is over. After a few frantic\nweeks, I've completed both parts of all 25 puzzles.\nAnd, like most years, it was a wild ride, full of frustration and triumph in equal\nmeasure. Eric Wastl and his team have once again delivered.\nWhen I wasn't coding, I was scanning documentation or trawling the [subreddit](https://www.reddit.com/r/adventofcode/) for hints.\nTo my surprise, I managed to finish the whole calendar before the New Year. The year felt a little easier than 2021, though of course\nI have much more experience than I did then.\n\nThis year's narrative had the player assisting the Elves' expedition deep into\nthe jungle, in search of a rare fruit that powers the reindeer's flight.\nThis premise has lower stakes than past years, which had you scrambling to\nprevent some catastrophe from ruining Christmas, but the change of pace is welcome.\n\nWe all know the plot is just a device to string puzzle premises together,\nbut I make special note of it because I think it's the secret to Advent of\nCode's popularity. Problems are just more enjoyable when framed by a silly scenario.\n\"Find the path on this unidirected graph maximizing this dynamic weighting function\"\nis a work specification; \"Find which valves to open release as\nmuch pressure as possible so you and the herd of elephants following you can\nescape the erupting volcano\" is _fun_.\n\n(One other amusing consequence of the narrative: if you follow the common\nstyle advice to name variables and functions in terms of the problem you are\nmodeling, your code will teem with names like `ModulusMonkey` and `nearest_elf`).\n\nI set out to use as many languages as possible,\neven those I lacked confidence in. For the first week or so, I found this easier than expected. Even JavaScript, which I hadn't used seriously in a long time, I found simple enough to use.\nBut it couldn't last. As the puzzles got tougher past day 10 or so, I found myself retreating to the familiarity of Python. Maybe I'll do better in this regard next year.\n\nHere's a plot showing my choice of language for each day with the cumulative line count:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nsource(\"plot_lines.R\")\nprint(plot)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n# Methods\n\nIf this year had a theme, it was [Cartesian coordinates](https://en.wikipedia.org/wiki/Cartesian_coordinate_system). They show up in at least a few puzzles each year,\nbut they showed up again and again this year. The concept often appeared\nwith a clever twist, such as modeling falling shapes (day 17) or computing\nthree-dimensional surface areas (day 18).\n\nFor these types of problems, I like to use a sparse map that\nstores only coordinates that matter for the problem. For day 18, for example, this was coordinates covered by a falling shape.\nI once used tuples to represent even two-dimensional coordinates, but now I use a tried-and-true hack: complex\nnumbers. Not only is this trick effective, it gives me the guilty thrill of\nusing a workaround it would be reckless to use in production code.\n\nAs always, a few problems frustrated me. Day 9 caught\nme off guard. It's tricky, but nothing terrible: each knot on the rope\nfollows simple movement rules that you can infer by studying the example input.\nInstead, I developed a complicated solution for part 1 that wouldn't\ngeneralize to part 2. The problem became easy when I took a break and realized\nall I had to do was keep each knot adjacent to its leading knot.\n\nDay 11 stymied me for a different reason: it could be solved a simple trick that\nI _just couldn't see_. Part 2 introduces a rule change that allows certain values\nto grow without bound. You have to recognize that they follow a cycle whose period\nis the lowest common multiple of divisors specified in the problem, then\nmodulo divide by that value. This isn't too hard to figure out, but I missed it\nbecause I attacked the problem without thinking it through. I ended up finding the correct method\nonly after trying almost everything else. A little number theory would have saved me\na lot of trouble.\n\nI also got badly stuck on day 16, but that one was horrible for everyone, so\nthere's nothing to analyze.\n\n# Difficulty\n\nI think the puzzle design this year was perhaps the best yet. Many puzzles\nwere hard, some very hard, but none were complicated.\nI think good puzzles test two things: modeling the important features of a problem and to to\nadapting a standard algorithm to a novel situation.\nThose with complicated rules introduce an additional challenge: correctly implementing every\ndetail of the specification. This rewards diligence more than insight and\nmeans even tiny mistakes will yield the wrong answer. Complication isn't _unfair per\nse, and most real software specifications are very complicated. But\nfew people consider attending to minutiae the best part of programming;\nconsider the mixed reception to [2018 day 15](https://adventofcode.com/2018/day/15), which I'm not even brave enough to attempt.\n\nThis year, the hard puzzles were hard because a straightforward approach could not solve them. Days 16 and 19, probably the hardest, presented\ntough pathfinding scenarios. You had to wrangle each input into a graph structure (possibly implicit),\nthen find a way to reduce the problem space to a manageable size that [brepth-first search](https://xkcd.com/2407/) could handle.\nWithout some clever optimization, any solution would probably take much too long\nBoth tasks involve lateral thinking and creativity; implementing Wikipedia's Dijkstra pseudocode wouldn't cut it.\nSome puzzles involved simulation, but not\nwith complicated rules; the difficulty instead came from understanding\nthe subtleties in the interaction of simple rules (e.g., Day 9).\nOverall, the puzzles have become leaner but no less challenging. I appreciate\nthe work it must have taken to refine a successful formula and make it still better.\n\nI also encountered, or implemented for the first time, several other useful\ntechniques: cycle detection, bit-encoding subsets, flood-filling, and more.\nI never come out of a year without at least a few new tricks.\n\nMy favorite puzzle was day 21. I solved it in R. Part 1 is fairly simple, requiring you\nto parse and evaluate a large expression recursively. Part 2 introduces\na nasty escalation: one of the names referenced in the expression (the one labeled\n\"humn\", naturally, since the others refer to monkeys) is bound\nto an _unknown_ value, not a constant, and you have to solve for it.\n\nI've always liked expression manipulation. R, with its strong LISP influence,\nmakes it easy to convert between R code, objects representing the code's\n[abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree),\nand [S-expression-like](https://en.wikipedia.org/wiki/S-expression) lists\nof functions and arguments. So I attacked part 2 by converting the equation to\nbe solved into a nested list of S-expressions. Since the right side of the\nequation resolved to a constant, I could solve it by simply inverting each\noperation on the left-hand side until I had isolated the unknown.\nI learned later that several other approaches worked well, such as finding the solution\nby binary search or using complex-number hackery.\nIt was fun and rewarding to work through, and the part 2 twist is a classic.\n\n# Closing Thoughts\n\nOverall, it was a fun and rewarding year, and I'm mostly pleased with my performance.\nI approached puzzles strategically instead of instinctively. I mostly picked the right data structures, and\navoided overengineering my solutions. I knew enough about pathfinding algorithms\nto get through the tougher puzzles. Don't get me wrong: I'm a long way\nfrom the people who can crank out an idiomatic Python solution that runs in 50 microseconds\nany given day. But I'm improving, and that pleases me.\n\nI had better learn the [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem) before December 2023, though.\nCan't be too hard, right?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}