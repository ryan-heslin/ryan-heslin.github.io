{
  "hash": "2623e35d356b78948f4155da02734474",
  "result": {
    "markdown": "---\ntitle: \"Renaming Things in R\"\nauthor: \"Ryan Heslin\"\ndate: \"2023-07-29\"\ncategories: [\"r\"]\nurlcolor: \"blue\"\n---\n\n\nNaming things is one of the [two hard problems of computer science](https://skeptics.stackexchange.com/questions/19836/has-phil-karlton-ever-said-there-are-only-two-hard-things-in-computer-science). It seems like it should be easy. \nThen you start coding, try to come up with names that are consistent, succinct, precise, and evocative, and fail. \n\nR adds another layer of difficulty: internal names. Vectors (which most R objects\nare) can store names for each element, including recursively. This \nmakes it easier to understand objects' structure and allows you to subset by \nname rather than position:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nx <- list(a = 4, b = \"q\", c = c(a = 1, b = 2), 1:5)\nx$a\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [1] 4\n```\n:::\n\n```{.r .source .cell-code}\nx$c[[\"a\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [1] 1\n```\n:::\n:::\n\n\n(You can't use `$` to subset atomic vectors).\n\nR also has a system for altering the names of existing objects - or so it seems.\nThat system is the subject of this post.\n\nYou can do this with the syntax `names(x) <- new_names`. If the new vector of names is shorter than the old one, \nR will just fill the new names with `NA`. You can also use subassignment to change only some \nnames, subject to the same rules. Thus:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nnames(x)[c(1, 3)] <- c(\"w\", \"z\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- $w\n-- [1] 4\n-- \n-- $b\n-- [1] \"q\"\n-- \n-- $z\n-- a b \n-- 1 2 \n-- \n-- [[4]]\n-- [1] 1 2 3 4 5\n```\n:::\n\n```{.r .source .cell-code}\n# Legal but silly\nnames(x) <- \"a\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- $a\n-- [1] 4\n-- \n-- $<NA>\n-- [1] \"q\"\n-- \n-- $<NA>\n-- a b \n-- 1 2 \n-- \n-- $<NA>\n-- [1] 1 2 3 4 5\n```\n:::\n:::\n\n\nThis is awkward but workable. It also creates the misleading impression that \nyou are changing an object's names in place. \nR experts will know that R generally copies objects on modification, except environments.\nThe code above isn't really setting the names to a new value.\nRather, you're calling the `names<-` function to return a new object with changed names.\n(You can also call it directly in that form, \nif you hate whoever has to maintain your code).\n\nAs shown in Hadley Wickham's _Advanced R_, \nwhat really happens is [this](https://adv-r.hadley.nz/functions.html#replacement-functions):\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\n`*tmp*` <- x\nx <- `names<-`(`*tmp*`, `[<-`(names(`*tmp*`), c(1, 3), c(\"w\", \"z\")))\nrm(`*tmp*`)\n```\n:::\n\n\nThis spooky process happens behind the \nscenes, and the deletion of `*tmp*` (yes, that's a legal variable name)\ndestroys the evidence. The R user is none the wiser - at least until they \nsee something like the second line \nin the above chunk in an error traceback and investigate.\n\nYou can even create your own functions that work this way. Just add `<-` to the \nend of the function name, call the first argument \"x\" and the last \"value\", and you have a working \n\"replacement function.\" Presumably, the parser \ngives them special treatment, in one of R's several \"magic\" syntax rules. Here is \na JavaScript-esque replacement function that fails silently if \nthe index passed is invalid:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\n`nth<-` <- function(x, n, value) {\n  n <- as.integer(n)\n  if (n > 0 && n <= length(x)) {\n    x[[n]] <- value\n  }\n  x\n}\nnth(x, 2) <- 3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- $a\n-- [1] 4\n-- \n-- $<NA>\n-- [1] 3\n-- \n-- $<NA>\n-- a b \n-- 1 2 \n-- \n-- $<NA>\n-- [1] 1 2 3 4 5\n```\n:::\n:::\n\n\nIf you _really_ want to see how the \nsausage is made, you can read the \nrelevant R source code [here](https://github.com/wch/r-source/blob/bf306acb97ec645063a076122340ad47a75442ec/src/main/attrib.c#L900). \n\nIs this the most elegant way to handle \nthe delicate problems of naming and renaming? Maybe not. \nBut it works, and sometimes that's enough. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}