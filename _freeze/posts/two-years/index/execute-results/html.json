{
  "hash": "4d71ced889d9db350f76aa7072aece2a",
  "result": {
    "markdown": "---\ntitle: \"What a Difference Two Years Makes\"\nauthor: \"Ryan Heslin\"\ndate: \"2023-02-05\"\ncategories: [\"Advent of Code\"]\nurlcolor: \"blue\"\n---\n\n\n_This post contains spoilers for day 19 of Advent of Code 2017._\n\nIn the past few week, I've gone back and completed some [Advent of Code](https://adventofcode.com/) puzzles I never got around to finishing. While working through 2017, I\ncame across [Day 19](https://adventofcode.com/2017/day/19).\nIt asks you to traverse a line that extends across a map, with several\nchanges of direction. In\ntypical Advent of Code fashion, everything is presented as as a file of ASCII characters.\n(The title is also a [quality reference](https://en.wikipedia.org/wiki/Series_of_tubes).)\n\nI first attempted the puzzle in the summer of 2021, when I had no clue what I\nwas doing. I plunged in without a plan, and the code got messier and messier.\nI thought it made sense to represent the map as a matrix, but it made\nkeeping track of position complicated. I hadn't yet learned\nthat nothing makes a puzzle harder than the wrong choice of data structure. I\neventually hacked my way to a correct solution, but it was kludgy and slow. I felt exhausted rather than\ntriumphant.\n\nI won't subject you to the whole script. The first lines, containing the helper\nfunctions I wrote, give enough of an impression:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nlibrary(magrittr)\n\nindex2coords <- function(X, index) {\n  c(\n    ifelse(index %% nrow(X) == 0, nrow(X), index %% nrow(X)),\n    index %% ncol(X) + 1\n  )\n}\ncoords2index <- function(X, coords) {\n  coords[1] + nrow(X) * coords[2]\n}\n\nnext_direction <- function(input, coords, last_dir, passed, steps) {\n  candidates <- surrounds(input, coords)\n  excludes <- c(\n    l = \"r\",\n    r = \"l\",\n    u = \"d\",\n    d = \"u\"\n  )\n  candidates <-\n    candidates[rownames(candidates) != excludes[last_dir], ]\n  next_dir <-\n    rownames(candidates[input[candidates] != \" \", , drop = FALSE])\n  print(coords)\n  traverse(input,\n    coords,\n    dir = next_dir,\n    passed = passed,\n    steps = steps\n  )\n}\nsurrounds <- function(input, coords) {\n  base <- c(1, -1, 0, 0)\n  adds <- cbind(base, rev(base))\n  out <- sweep(adds,\n    FUN = `+`,\n    STATS = c(coords),\n    MARGIN = 2\n  )\n  rownames(out) <- c(\"d\", \"u\", \"l\", \"r\")\n  out[validate_coords(input, coords), ]\n}\nvalidate_coords <- function(input, coords) {\n  dims <- dim(input)\n  apply(coords, MARGIN = 1, function(x) {\n    all(x > 0 && x <= dims)\n  })\n}\n```\n:::\n\n\nVerbose and complicated.\n\nWondering how I could do better, I found a concise Python solution to the puzzle.\nIt cleverly used a dict of complex numbers to represent the map - a classic\nhack I had never though to use. I remembered the trick and moved on to to other\nproblems.\n\nA few months shy of two years passed. Then, one morning,\nI came back to the puzzle. In about twenty leisurely minutes, I came\nup with this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .source .cell-code}\nfrom operator import attrgetter\n\n\ndef parse(lines):\n    result = {}\n    for j, line in enumerate(lines):\n        for i, char in enumerate(line):\n            if char != \" \":\n                result[complex(i, j)] = char\n    return result\n\n\ndef neighbors(point):\n    return {\n        complex(point.real - 1, point.imag): -1 + 0j,\n        complex(point.real + 1, point.imag): 1 + 0j,\n        complex(point.real, point.imag - 1): 0 - 1j,\n        complex(point.real, point.imag + 1): 0 + 1j,\n    }\n\n\nwith open(\"inputs/day19.txt\") as f:\n    raw_input = f.read().splitlines()\n\ngrid = parse(raw_input)\nposition = min(grid.keys(), key=attrgetter(\"imag\"))\ndirection = 0 + 1j\nfound = \"\"\ntraversed = 0\nchar = \"-\"\n\nwhile char:\n    last = position\n    position += direction\n    char = grid.get(position, \"\")\n    traversed += 1\n    if char.isalpha():\n        found += char\n    elif char == \"+\":\n        this_neighbors = neighbors(position)\n        for dest, dir in this_neighbors.items():\n            if grid.get(dest) and dest != last:\n                direction = dir\n                break\n\nprint(found)\nprint(traversed)\n```\n:::\n\n\nThis is merely workmanlike, but compared to my original solution it may as well\nbe the source for the [Apollo Guidance Computer](https://en.wikipedia.org/wiki/Apollo_Guidance_Computer). I implemented the complex-number approach, as I now know to do,\nand the code practically wrote itself. After parsing the map, I simply have to\nkeep track of the position and direction of motion and update the motion one\nunit at a time. Changing directions at one of the junctions on the road\nthe puzzle simulates just means checking neighbors for the road's continuation. I use the empty\nstring to represent the end of the road and terminate the `while` loop.\n\nLooking back, I realized this puzzle wasn't really hard, at least for\nAdvent of Code. (For an example of \"hard\", see [here](https://adventofcode.com/2020/day/20).\nI struggled the first time from inexperience.\nWith experience, it came easily. So easily that it seems\namazing the problem ever seemed hard.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}