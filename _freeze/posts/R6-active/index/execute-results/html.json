{
  "hash": "86422ab335378a807006a930096b08c2",
  "result": {
    "markdown": "---\ntitle: \"Programatically Creating Accessor Functions for R6 Objects\"\nauthor: \"Ryan Heslin\"\ndate: \"2022-06-25\"\ncategories: [\"R\"]\ntags: [\"metaprogramming\"]\nparams:\n    title: \"Programatically Creating Accessor Functions for R6 Objects\"\n---\n\n\nOne nice feature of R6 objects is active fields. Normally, to expose a field to\nthe user, you have pass it to the `public` argument of the `R6Class` constructor.\nThat makes it accessible, but also permits the user to meddle with it.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(R6)\n\nunprotected <- R6Class(\n  classname = \"unprotected\",\n  public = list(foo = 1, bar = 2, baz = 3)\n)\nexample <- unprotected$new()\nexample$foo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 1\n```\n:::\n\n```{.r .cell-code}\nexample$foo <- 2\nexample$foo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 2\n```\n:::\n:::\n\n\nFields can be protected by sending them to `private` instead, but that blocks the\nuser from accessing them. The solution is\nto create an `active` field. This creates an active binding: a special form of R\nfunction that can be used to return a value\nif called with no arguments and to bind a value if called with one. We can use\nthis capability to create an accessor function that blocks users from changing values:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprotected <- R6Class(\n  classname = \"example\",\n  public = list(\n    bar = 2, baz = 3,\n    initialize = function(foo) private$.foo <- foo\n  ),\n  private = list(.foo = NULL),\n  active = list(foo = function(value) {\n    if (missing(value)) {\n      return(private$.foo)\n    } else {\n      stop(\"Hands off!\")\n    }\n  })\n)\n\nexample <- protected$new(foo = 1)\nexample$foo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 1\n```\n:::\n\n```{.r .cell-code}\nexample$foo <- 2\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in (function (value) : Hands off!\n```\n:::\n:::\n\n\n(See [chapter 14 of Advanced R](https://adv-r.hadley.nz/r6.html) for more details).\n\nThis is all simple enough, but there's an obvious problem: what if we have a lot\nof attributes to protect? We could dodge the\nproblem by combining them into a single list\nattribute, or just copy-paste the same function with\ndifferent attribute names. But those\noptions aren't always attractive. I recently\nconfronted this problem while working on\nan elaborate subclass of `torch::dataset`,\nwhich organizes data for neural networks.\nI decided to rifle through my bag of functional programming tricks in search of a solution.\n\n# First Attempt: Function Factory\n\nSince each active field requires a function, a function factory was an obvious approach. It's simple to implement:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\naccessor_factory <- function(field) {\n  force(field)\n  function(value) {\n    if (missing(value)) {\n      return(private[[\"field\"]])\n    } else {\n      stop(\"Hands off \", field, \"!\")\n    }\n  }\n}\n```\n:::\n\n\n(The real version used a less jocular error message, but I need to have my fun somehow).\nBecause R has lexical scope, `field` is bound in the manufactured function's enclosing\nenvironment, so when executed it should look there and find it.\n\nBut it doesn't work.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprotected <- R6Class(\n  classname = \"example\",\n  public = list(\n    bar = 2, baz = 3,\n    initialize = function(foo) private$.foo <- foo\n  ),\n  private = list(.foo = NULL),\n  active = list(foo = accessor_factory(\".foo\"))\n)\nexample <- protected$new(1)\nexample$foo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- NULL\n```\n:::\n\n```{.r .cell-code}\nexample$foo <- 2\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in (function (value) : object 'field' not found\n```\n:::\n:::\n\n\nEither R core sneaked support for dynamic scope into the last major version, or the `R6Class` constructor was doing something funny. Checking the source code found the offending line:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngenerator_funs <- assign_func_envs(generator_funs, generator)\n```\n:::\n\nThe constructor modified the environments of function fields (a trick I also resorted to while writing a different subclass, but that's another story). Relying on scope\nwouldn't help, but what would?\n\n# Second Attempt: `as.function`\n\nMy next idea was to use R's obscure but powerful function constructor, `as.function`. It has a strange implementation: it takes a list, interpreting all elements except the last as name-value pairs for arguments (with an empty value slot designating an argument with no default). The last element should be an expression defining\nthe function body. This is what I wrote:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\naccessor_factory <- function(field) {\n  force(field)\n  code <- substitute(\n    {\n      if (missing(value)) {\n        return(private[[field]])\n      } else {\n        stop(sQuote(field), \" is read-only\")\n      }\n    },\n    list(field = field)\n  )\n  as.function(eval(substitute(\n    alist(value = , code),\n    list(code = code)\n  )),\n  envir = globalenv()\n  )\n}\n```\n:::\n\n\nThis code demands some explanation.\nThe idea is to return a function with the\nvalue of `field` _already substituted_, not\nset at runtime.\nThe first step uses `substitute` to replace\nthe symbol `field` with the value passed to the function (i.e., the name of the target attribute). The result forms\nthe body of the manufactured function. I\nhave to call `substitute` _again_ to substitute this expression into the call to `alist` passed to `as.function`, because `alist` quotes its arguments. That expression\nactually creates the function we need. (See why most people consider me weird for liking metaprogramming?).\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprotected <- R6Class(\n  classname = \"example\",\n  public = list(\n    bar = 2, baz = 3,\n    initialize = function(foo) private$.foo <- foo\n  ),\n  private = list(.foo = NULL),\n  active = list(foo = accessor_factory(\".foo\"))\n)\nexample <- protected$new(1)\nexample$foo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 1\n```\n:::\n\n```{.r .cell-code}\nexample$foo <- 2\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in (function (value) : '.foo' is read-only\n```\n:::\n:::\n\n\nThis works. But can we do better?\n\n# Third Attempt: Body Substitution\n\nR features assignment functions to modify all\nthree parts of a closure: formal arguments,\nbody, and environment. We're interested in creating a set of functions with slightly different bodies, so pairing `body<-` with `substitute` is a natural approach. It's a lot more\nreadable than my last attempt, too. The classic\ndouble-substitute trick for substituting the\nresult of an expression comes from Advanced R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsubstitute_body <- function(fn, mapping) {\n  body(fn) <- eval(substitute(substitute(temp, mapping), list(temp = body(fn))))\n  fn\n}\n\ntemplate <- function(value) {\n  if (missing(value)) {\n    return(private[[field]])\n  } else {\n    stop(sQuote(field), \" is read-only\")\n  }\n}\nsubstitute_body(template, mapping = list(field = \"test\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (value) \n-- {\n--     if (missing(value)) {\n--         return(private[[\"test\"]])\n--     }\n--     else {\n--         stop(sQuote(\"test\"), \" is read-only\")\n--     }\n-- }\n```\n:::\n:::\n\n\nVictory! Well, almost. To make this truly useful, we need a wrapper function to\ncreate a list of accessors from field names.\nThankfully, that's much easier than figuring out the substitution.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset_active_fields <- function(fields) {\n  out <- lapply(fields, function(x) {\n    substitute_body(\n      fn = template,\n      mapping = list(field = x)\n    )\n  })\n  names(out) <- gsub(\"^\\\\.\", \"\", fields)\n  out\n}\n```\n:::\n\n\nA bog-standard use of `lapply` does the job, with the annoying complication of removing leading dots from the names\nof private fields.\n\nWe can even go one step further and write a wrapper to `R6Class` to automatically create accessors from a list of private attributes.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwith_accessors <- function(classname = NULL,\n                           public,\n                           private,\n                           inherit = NULL, lock_objects = TRUE,\n                           class = TRUE,\n                           portable = TRUE, lock_class = FALSE,\n                           cloneable = TRUE,\n                           parent_env = (function() parent.frame())()) {\n  force(parent_env)\n  active <- set_active_fields(names(private))\n  R6Class(\n    classname = classname, public = public,\n    private = NULL, active = active,\n    inherit = inherit, lock_objects = lock_objects,\n    class = class,\n    portable = portable,\n    lock_class = lock_class,\n    cloneable = cloneable,\n    parent_env = parent_env\n  )\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npublic <- list(initialize = function(foo) {\n  private$.foo <<- foo\n})\nprivate <- list(.foo = NULL, .bar = 2, .baz = 3)\nprotected <- with_accessors(\"example\", public = public, private = private)\n\nexample <- protected$new(foo = 1)\nexample$foo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 1\n```\n:::\n\n```{.r .cell-code}\nexample$bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 2\n```\n:::\n\n```{.r .cell-code}\nexample$baz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 3\n```\n:::\n\n```{.r .cell-code}\nexample$foo <- 2\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in (function (value) : '.foo' is read-only\n```\n:::\n\n```{.r .cell-code}\nexample$baz <- 5\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in (function (value) : '.baz' is read-only\n```\n:::\n:::\n\n\nNote that because of the indirection, I have to use `<<-` in `initialize`. I\nalso have to make `parent_env` the execution environment of the wrapper, which is the caller environment of `R6Class` here. There may also be other nasty surprises buried in this use of reference semantics. Still, this was a fun\ndiversion, and proof of how much power\nR grants the user over environments and evaluation.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}