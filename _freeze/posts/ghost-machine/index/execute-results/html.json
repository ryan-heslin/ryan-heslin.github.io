{
  "hash": "32c7bdd2b4b9cba2c10179433503b5d3",
  "result": {
    "markdown": "---\ntitle: \"Ghost in the Machine: The Remnant of R's Past That Haunts it Still\"\nauthor: \"Ryan Heslin\"\ndate: \"2022-06-12\"\ncategories: [\"R\"]\nparams:\n    title: \"Ghost in the Machine: The Remnant of R's Past That Haunts it Still\"\n---\n\n\nAs programming languages go, R isn't particularly old: its first public release came in\nearly 2000 (see [https://www.stat.auckland.ac.nz/~ihaka/downloads/Massey.pdf](https://www.stat.auckland.ac.nz/~ihaka/downloads/Massey.pdf) for more details).\n\nBut as many users know, its roots\ngo back further. R was developed from the language S, created in the 1970s by a team led by John Chambers at Bell Labs.\nThose were the glory days of Bell Labs, when the language C and the Unix ecosystem were developed. Like a modern palace built on the foundations of an ancient one,\nR bears many traces of its lineage. Syntax is very similar, many features are backward-compatible,\nand the documentation for some functions even refers to resources about S rather than R.\n(Try `?sum`, for one example).\n\n(I can't help but pause here to relay the account the linked presentation gives of R's origins.\nIt all began with this hallway conversation between Ross Ihaka and Robert Gentleman in the University of Auckland around 1990):\n<blockquote cite=\"https://www.stat.auckland.ac.nz/~ihaka/downloads/Massey.pdf\">\nGentleman: “Let’s write some software.”\n\nIhaka: “Sure, that sounds like fun.”\n</blockquote>\n\nOne of those traces, harder to observe but certainly still present, is also one of R's\nmost unusual (and, in some quarters, derided) features: an emphasis on convenience\nin interactive use.  Interpreted languages typically support interactivity in some way, since the ability to run a snippet of code and instantly get results is\none of their greatest advantages over compiled languages. But S was designed primarily for interactive data exploration, and R has retained that capability as a design focus.\nIn areas great and small, from core design\nchoices to implementation quirks, R makes it\nas easy as possible to bang out code in the console and see what happens. That makes it a fast, flexible tool for exploring data and following hunches. It also strews mines in the path of anyone programming in the language without detailed knowledge of the\nits nuances.\n\nA few examples will make this painfully clear.\n\n# Partial Matching, Complete Headache\n\nCan you spot the problem with this call? It runs correctly:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nrep(1:3, length = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n--  [1] 1 2 3 1 2 3 1 2 3 1\n```\n:::\n:::\n\n\nbut is missing something. The relevant argument of `rep` is actually called `length.out`, not `length`, but R's partial argument matching saves us, since `length` is a shortened form of `length.out`.\n\nThis is nice to have when typing code in the console. But relying on partial argument matching in scripts is a _very_ bad idea.\n\nSuppose you're working with a package that includes some functions with annoyingly long argument names. All that typing is annoying, so you decide you may as well save some keystrokes:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nfoo <- function(xyzabc = 0, abcxyz) {\n  rnorm(100, mean = xyzabc, sd = abcxyz)\n}\nfoo(abc = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n--   [1] -2.2445375393  0.0006980033  2.7545888572\n--   [4]  2.4408344499  1.0603102701  1.0339639753\n--   [7] -2.5538325776 -2.3821797163  1.4241402187\n--  [10]  3.4608888276 -1.7982607952 -2.6028331590\n--  [13] -1.9567956312  3.0330076639  1.6970384912\n--  [16] -1.6846503588  0.7703500154  2.0788886200\n--  [19] -1.4633401345 -0.5573480895 -2.0095198162\n--  [22] -1.6895435431  3.1311811856  3.1310047213\n--  [25]  1.4729583077 -1.0263057542 -1.5847273796\n--  [28] -0.4799545029 -1.7888803568 -1.9245995464\n--  [31] -4.6330110103 -1.9715598153  1.4599438684\n--  [34]  2.7132587288  0.6528931467  2.5852043149\n--  [37]  1.0905654293  0.2725256704  1.6970369709\n--  [40] -2.0199561628  2.5247942430 -0.7553546067\n--  [43] -2.1349384104  2.9145587148 -0.7345825950\n--  [46] -5.1058990327  4.9231247499 -0.6035536464\n--  [49] -2.3265457843  0.3302235222 -1.3918293057\n--  [52]  1.0125287082  1.0594286242  0.3381375636\n--  [55] -2.6480325601  2.6698135931  0.6011187892\n--  [58]  0.8268423770  2.0615727017  0.7820518214\n--  [61]  0.8661731658  1.6124350173 -3.4892935968\n--  [64]  1.1309708077 -2.6950092921  1.3708731989\n--  [67]  0.8005728911  1.9657901299 -0.0740493745\n--  [70] -1.9168890455 -0.4764915602  1.0063471749\n--  [73] -1.0145137420 -2.9367465377  1.8716120776\n--  [76]  2.5652162753 -4.1357088596  0.1449861917\n--  [79] -0.1510655209  0.8926796265  2.0724077350\n--  [82]  0.8070621653 -2.2783598309 -2.1981171179\n--  [85]  0.2787279686 -0.6897820741  0.2305332864\n--  [88]  3.7423003005 -0.5410520289 -0.0798217270\n--  [91]  2.2024273761  2.0151796646  0.1497940941\n--  [94]  1.7381047108  4.8335993704 -1.0045015749\n--  [97]  0.4051954986 -0.7421079463  1.3928131504\n-- [100] -0.3842254215\n```\n:::\n:::\n\n\nAll seems well. But then a version update adds a new argument:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nfoo <- function(abcabc = 100, xyzabc = 0, abcxyz) {\n  rnorm(abcabc, mean = xyzabc, sd = abcxyz)\n}\nfoo(abc = 2)\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in foo(abc = 2): argument 1 matches multiple formal arguments\n```\n:::\n:::\n\n\nR throws an error, unable to find an unambiguous match. (Imagine how painful this would be to debug if R defaulted to the first match instead). The way to avoid this scenario is simple: never rely on partial argument matching in permanent code. Nonetheless, many packages do. You can identify offenders yourself by setting the `warnPartialMatchArgs` option:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\noptions(warnPartialMatchArgs = TRUE)\nfoo <- function(xyzabc = 0, abcxyz) {\n  rnorm(100, mean = xyzabc, sd = abcxyz)\n}\nfoo(abc = 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Warning in foo(abc = 2): partial argument match of\n-- 'abc' to 'abcxyz'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n--   [1]  1.135737632  0.898777992 -1.168305721\n--   [4] -0.200356691  1.896926857 -2.195331088\n--   [7] -2.358100545 -0.964742402 -0.434256333\n--  [10] -0.866615153 -1.695076565 -1.216676274\n--  [13] -0.701648479  0.116874260  1.539296099\n--  [16] -1.855742680  0.668820756  0.956655247\n--  [19] -0.877439502 -0.587614465 -2.665958758\n--  [22]  1.773477792 -2.863720703  3.763074651\n--  [25]  0.465025688 -0.769830396 -2.432551929\n--  [28] -1.014383156 -2.612857969  2.458936219\n--  [31]  4.574751630  1.904787119 -1.296354990\n--  [34] -1.255039919 -2.211310672  2.345390787\n--  [37] -4.428351645  1.320426681  3.489979652\n--  [40]  0.096533032  0.458937039 -0.102943023\n--  [43] -1.250962819 -1.985484776 -1.218318017\n--  [46]  1.326497455 -1.508000185  0.677995117\n--  [49] -1.311472616  0.827359346 -0.021029545\n--  [52] -1.573747438 -0.468632693  2.537835106\n--  [55] -0.322118384 -1.811239945 -2.142289035\n--  [58] -1.474554406  0.167728454 -0.747559158\n--  [61]  1.643024687  5.315610537 -0.454848607\n--  [64]  0.334280121  0.407075141  2.832402127\n--  [67]  4.496262431  4.541043228  1.615224374\n--  [70] -0.809748220  0.172601480 -0.818599327\n--  [73] -2.450540595  1.267560384  1.585044337\n--  [76]  4.241263923 -3.659138113  2.707283449\n--  [79] -0.005228332  3.708947137  2.734984132\n--  [82]  3.740473434 -2.344453443 -1.725388978\n--  [85]  2.835911189  1.903218359 -2.937334230\n--  [88]  1.012619409 -1.685953117  0.284221601\n--  [91]  1.660654555  4.480118551  0.001522222\n--  [94] -3.086320143 -2.858898255  2.692280552\n--  [97] -1.012438393  0.107822384 -1.982872158\n-- [100]  2.153669313\n```\n:::\n:::\n\n\n# When Simplification Complicates\n\nR is an example of a weakly typed language with dynamic typing. That means data types are\nknown only at runtime, not before, and that the language will try to coerce disparate\ntypes to a common type instead of throwing an error. That means the interpreter will happily run code like\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\npaste(mtcars, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n--  [1] \"c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, 19.7, 15, 21.4) 1\"                    \n--  [2] \"c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4) 1\"                                                                                                            \n--  [3] \"c(160, 160, 108, 258, 360, 225, 360, 146.7, 140.8, 167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 75.7, 71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 145, 301, 121) 1\"                       \n--  [4] \"c(110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150, 150, 245, 175, 66, 91, 113, 264, 175, 335, 109) 1\"                                                     \n--  [5] \"c(3.9, 3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92, 3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76, 3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11) 1\"                  \n--  [6] \"c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, 3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2, 1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 2.14, 1.513, 3.17, 2.77, 3.57, 2.78) 1\"  \n--  [7] \"c(16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 17.6, 18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87, 17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6) 1\"\n--  [8] \"c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1) 1\"                                                                                                            \n--  [9] \"c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1) 1\"                                                                                                            \n-- [10] \"c(4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3, 4, 5, 5, 5, 5, 5, 4) 1\"                                                                                                            \n-- [11] \"c(4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, 2, 2, 4, 6, 8, 2) 1\"\n```\n:::\n:::\n\n\n`paste` just coerces everything to character, no matter how ludicrous the results. This behavior can trip you up, but it's not truly insidious.\n\nUnfortunately, R sometimes changes types under your nose. Suppose we write a function, `subset2`. It takes as argument a data frame, and two  functions that take a data frame as argument. It filters the data column-wise using `col_f`, then rowwise using `row_f`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nsubset2 <- function(df, col_f, row_f) {\n  df <- df[, col_f(df)]\n  df[row_f(df), ]\n}\nsubset2(mtcars, \\(x) colSums(x) > 500, \\(x) rowSums(x) > 500)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"mpg\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"disp\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"hp\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"qsec\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"18.7\",\"2\":\"360\",\"3\":\"175\",\"4\":\"17.02\",\"_rn_\":\"Hornet Sportabout\"},{\"1\":\"14.3\",\"2\":\"360\",\"3\":\"245\",\"4\":\"15.84\",\"_rn_\":\"Duster 360\"},{\"1\":\"10.4\",\"2\":\"472\",\"3\":\"205\",\"4\":\"17.98\",\"_rn_\":\"Cadillac Fleetwood\"},{\"1\":\"10.4\",\"2\":\"460\",\"3\":\"215\",\"4\":\"17.82\",\"_rn_\":\"Lincoln Continental\"},{\"1\":\"14.7\",\"2\":\"440\",\"3\":\"230\",\"4\":\"17.42\",\"_rn_\":\"Chrysler Imperial\"},{\"1\":\"15.5\",\"2\":\"318\",\"3\":\"150\",\"4\":\"16.87\",\"_rn_\":\"Dodge Challenger\"},{\"1\":\"13.3\",\"2\":\"350\",\"3\":\"245\",\"4\":\"15.41\",\"_rn_\":\"Camaro Z28\"},{\"1\":\"19.2\",\"2\":\"400\",\"3\":\"175\",\"4\":\"17.05\",\"_rn_\":\"Pontiac Firebird\"},{\"1\":\"15.8\",\"2\":\"351\",\"3\":\"264\",\"4\":\"14.50\",\"_rn_\":\"Ford Pantera L\"},{\"1\":\"15.0\",\"2\":\"301\",\"3\":\"335\",\"4\":\"14.60\",\"_rn_\":\"Maserati Bora\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThat seems to work. (Deadly words!) But what if my finger had slipped when I typed `500`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nsubset2 <- function(df, col_f, row_f) {\n  df <- df[row_f, col_f(df)]\n  df[row_f(df), ]\n}\nsubset2(mtcars, \\(x) colSums(x) > 5000, \\(x) rowSums(x) > 500)\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in xj[i]: invalid subscript type 'closure'\n```\n:::\n:::\n\n\nWhat happened? Only one column of `mtcars`, `disp`, has a column sum greater than 5000. And what happens if you select a single column with array-style indexing?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nmtcars[, \"disp\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n--  [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0\n--  [8] 146.7 140.8 167.6 167.6 275.8 275.8 275.8\n-- [15] 472.0 460.0 440.0  78.7  75.7  71.1 120.1\n-- [22] 318.0 304.0 350.0 400.0  79.0 120.3  95.1\n-- [29] 351.0 145.0 301.0 121.0\n```\n:::\n:::\n\n\nR helpfully simplifies to an atomic vector. We can fix our function by disabling this behavior:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nsubset3 <- function(df, col_f, row_f) {\n  df <- df[, col_f(df), drop = FALSE]\n  df[row_f(df), ]\n}\nsubset3(mtcars, \\(x) colSums(x) > 5000, \\(x) rowSums(x) > 500)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- numeric(0)\n```\n:::\n:::\n\n\nor, even more sensibly, using list subsetting (single brackets, no comma), which never simplifies.\n\nThis behavior isn't indefensible. It's consistent with how subsetting works on arrays (which are usually atomic vectors). In interactive use, it's convenient, since then you're usually interested in the data a column contains, not the object containing it. But automatic simplification is easily missed and potentially destructive, and the way to avoid it can be found only if you carefully read the documentation.\n\n# Brevity is the Soul of Bugs\n\nSuppose you have the following vector:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nx <- c(1, 4, 7, NA, -9, NA)\n```\n:::\n\n\nR is strict about missing values, but not about logical constants. `T` and `F` can be used as abbreviations for `TRUE` and `FALSE`, respectively. The following is a valid way of taking the mean:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nmean(x, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [1] 0.75\n```\n:::\n:::\n\n\nLikewise, with `F` for `FALSE`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nmtcars[1:5, \"cyl\", drop = F]\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"cyl\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"6\",\"_rn_\":\"Mazda RX4\"},{\"1\":\"6\",\"_rn_\":\"Mazda RX4 Wag\"},{\"1\":\"4\",\"_rn_\":\"Datsun 710\"},{\"1\":\"6\",\"_rn_\":\"Hornet 4 Drive\"},{\"1\":\"8\",\"_rn_\":\"Hornet Sportabout\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nWhat's the harm in this? While `TRUE` and `FALSE` are reserved words, the abbreviations _aren't_. Let's say your colleague creates a variable `T`, making sure to use uppercase to avoid masking the `t` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nT <- pt(2, df = 10)\n```\n:::\n\n\nThis code now fails in a confusing way:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .source .cell-code}\nmean(x, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.output}\n-- [1] NA\n```\n:::\n:::\n\n\nThe reason for this feature, as before, is clear: it's convenient in interactive use. The problem with it is equally clear: it's suicidal in programmatic use.\n\n# Conclusion\n\nThe theme here is obvious: features that save a few keystrokes in interactive use can cause maddening bugs if carelessly used in production code. You need familiarity with the language and some degree of vigilance to avoid the pitfalls, and everyone slips now and again.\n\nThe longer I've spent with R, the more convinced I've become that R has outgrown these features. R was designed as an environment for interactive data exploration, statistical testing, and graphical displays, but today it can do so much more: serve Web apps, query remote databases, render just about any document (even this one) with Rmarkdown or Quarto, and many other uses.\nBut to fulfill these sophisticated use cases, you have to carefully avoid traps like the ones discussed here. Some organizations have no doubt avoided the problem by switching to Python. So R's design emphasis on interactivity may limit its growth.\n\nMoreover, the benefits these features deliver are scant. The three behaviors I describe - partial argument matching, logical abbreviations, and `drop = FALSE` save a bit of typing (or, in the last case, an extra step of data manipulation). A few key strokes saved here and there adds up quickly, and the savings \nmay have been significant in the days when users were limited to R's basic `readline` prompt. But that doesn't balance the potential harm they can cause in production code today, especially when modern IDEs (and Vim or Emacs, of course) support autocompletion, obviating the need for abbreviated code.\n\nDon't get me wrong. R remains a powerful, expressive language built on solid design principles. It's my first choice for any kind of data manipulation, and I still find it fun and satisfying to use. But some of its behaviors are more at home in its past than its future.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}