{
  "hash": "db4df2e0e0f2e0ec21214b443c7b2a91",
  "result": {
    "markdown": "---\ntitle: \"R Tricks I Wish I'd Known as a Beginner\"\nauthor: \"Ryan Heslin\"\ndate: \"2022-06-18\"\ncategories: [\"R\"]\nparams:\n    title: \"R Tricks I Wish I'd Known as a Beginner\"\n---\n\n\nR is full of quirks, some of them obscure.\nGetting the most out of the language takes some experience, but is well worth the effort.\nThese techniques will be old hat to seasoned R users, but you never know: you might still learn something.\n\n# Bind Multiple Names to the Same Value At Once\n\nThe assignment operator `<-` (like its right- and super-assigning cousins) is actually a function that\nreturns its right-hand side. That means code like:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 5\ny <- 5\nz <- 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 5\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 5\n```\n:::\n\n```{.r .cell-code}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 5\n```\n:::\n:::\n\n\ncan be condensed into one line.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\nx <- y <- z <- 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 5\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 5\n```\n:::\n\n```{.r .cell-code}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] 5\n```\n:::\n:::\n\n\nThis does nothing but make your code more readable, but\nit's still good to know.\n\n# Examine the Source Code of Functions, Wherever It Hides\n\nWhen the documentation fails to resolve a question, the next step is learning what the function actually does. For closures (which are most R functions), inspecting the source code is as simple as entering the function's name in the console:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetNames\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (object = nm, nm) \n-- {\n--     names(object) <- nm\n--     object\n-- }\n-- <bytecode: 0x560f820fe2b8>\n-- <environment: namespace:stats>\n```\n:::\n\n```{.r .cell-code}\ntapply\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE) \n-- {\n--     FUN <- if (!is.null(FUN)) \n--         match.fun(FUN)\n--     if (inherits(INDEX, \"formula\")) {\n--         if (is.data.frame(X)) \n--             INDEX <- .formula2varlist(INDEX, X)\n--         else stop(\"'X' must be a data frame when 'INDEX' is a formula\")\n--     }\n--     if (!is.list(INDEX)) \n--         INDEX <- list(INDEX)\n--     INDEX <- lapply(INDEX, as.factor)\n--     nI <- length(INDEX)\n--     if (!nI) \n--         stop(\"'INDEX' is of length zero\")\n--     if (!is.object(X) && !all(lengths(INDEX) == length(X))) \n--         stop(\"arguments must have same length\")\n--     namelist <- lapply(INDEX, levels)\n--     extent <- lengths(namelist, use.names = FALSE)\n--     cumextent <- cumprod(extent)\n--     if (cumextent[nI] > .Machine$integer.max) \n--         stop(\"total number of levels >= 2^31\")\n--     storage.mode(cumextent) <- \"integer\"\n--     ngroup <- cumextent[nI]\n--     group <- as.integer(INDEX[[1L]])\n--     if (nI > 1L) \n--         for (i in 2L:nI) group <- group + cumextent[i - 1L] * \n--             (as.integer(INDEX[[i]]) - 1L)\n--     if (is.null(FUN)) \n--         return(group)\n--     levels(group) <- as.character(seq_len(ngroup))\n--     class(group) <- \"factor\"\n--     ans <- split(X, group)\n--     names(ans) <- NULL\n--     index <- as.logical(lengths(ans))\n--     ans <- lapply(X = ans[index], FUN = FUN, ...)\n--     ansmat <- array(if (simplify && all(lengths(ans) == 1L)) {\n--         ans <- unlist(ans, recursive = FALSE, use.names = FALSE)\n--         if (!is.null(ans) && is.na(default) && is.atomic(ans)) \n--             vector(typeof(ans))\n--         else default\n--     }\n--     else vector(\"list\", prod(extent)), dim = extent, dimnames = namelist)\n--     if (length(ans)) {\n--         ansmat[index] <- ans\n--     }\n--     ansmat\n-- }\n-- <bytecode: 0x560f829b9c88>\n-- <environment: namespace:base>\n```\n:::\n:::\n\n\nIn my experience, beginners often don't think to do this, perhaps because they don't grasp that functions are first-class objects that can be interacted with.\n\nWe have to do a little more work if the function in question is actually an S3 generic, or is not exported from the package it belongs to. In the first case, we can use the fact that S3 methods are generally\nnamed `genericname.classname`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint.data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (x, ..., digits = NULL, quote = FALSE, right = TRUE, \n--     row.names = TRUE, max = NULL) \n-- {\n--     n <- length(row.names(x))\n--     if (length(x) == 0L) {\n--         cat(sprintf(ngettext(n, \"data frame with 0 columns and %d row\", \n--             \"data frame with 0 columns and %d rows\"), n), \"\\n\", \n--             sep = \"\")\n--     }\n--     else if (n == 0L) {\n--         print.default(names(x), quote = FALSE)\n--         cat(gettext(\"<0 rows> (or 0-length row.names)\\n\"))\n--     }\n--     else {\n--         if (is.null(max)) \n--             max <- getOption(\"max.print\", 99999L)\n--         if (!is.finite(max)) \n--             stop(\"invalid 'max' / getOption(\\\"max.print\\\"): \", \n--                 max)\n--         omit <- (n0 <- max%/%length(x)) < n\n--         m <- as.matrix(format.data.frame(if (omit) \n--             x[seq_len(n0), , drop = FALSE]\n--         else x, digits = digits, na.encode = FALSE))\n--         if (!isTRUE(row.names)) \n--             dimnames(m)[[1L]] <- if (isFALSE(row.names)) \n--                 rep.int(\"\", if (omit) \n--                   n0\n--                 else n)\n--             else row.names\n--         print(m, ..., quote = quote, right = right, max = max)\n--         if (omit) \n--             cat(\" [ reached 'max' / getOption(\\\"max.print\\\") -- omitted\", \n--                 n - n0, \"rows ]\\n\")\n--     }\n--     invisible(x)\n-- }\n-- <bytecode: 0x560f7f9b4b80>\n-- <environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nmean.default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (x, trim = 0, na.rm = FALSE, ...) \n-- {\n--     if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {\n--         warning(\"argument is not numeric or logical: returning NA\")\n--         return(NA_real_)\n--     }\n--     if (isTRUE(na.rm)) \n--         x <- x[!is.na(x)]\n--     if (!is.numeric(trim) || length(trim) != 1L) \n--         stop(\"'trim' must be numeric of length one\")\n--     n <- length(x)\n--     if (trim > 0 && n) {\n--         if (is.complex(x)) \n--             stop(\"trimmed means are not defined for complex data\")\n--         if (anyNA(x)) \n--             return(NA_real_)\n--         if (trim >= 0.5) \n--             return(stats::median(x, na.rm = FALSE))\n--         lo <- floor(n * trim) + 1\n--         hi <- n + 1 - lo\n--         x <- sort.int(x, partial = unique(c(lo, hi)))[lo:hi]\n--     }\n--     .Internal(mean(x))\n-- }\n-- <bytecode: 0x560f7f8770b8>\n-- <environment: namespace:base>\n```\n:::\n:::\n\n\nIn the second case, we can use\nthe `:::` function, `::`'s nosier cousin, to access a non-exported object:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntidyselect:::where\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (fn) \n-- {\n--     predicate <- as_function(fn)\n--     call <- current_call()\n--     function(x, ...) {\n--         out <- predicate(x, ...)\n--         check_predicate_output(out, call = call)\n--         out\n--     }\n-- }\n-- <bytecode: 0x560f80e989b0>\n-- <environment: namespace:tidyselect>\n```\n:::\n:::\n\n\nIt's seldom a good idea to _use_ non-exported functions, because they probably weren't exported for a reason!\n\nOf course, for primitives and certain special functions,\nthe source code isn't in R to begin with:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- function (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n:::\n:::\n\n\nTo understand how those work, you'll have to find the appropriate file in the R source code and read the C code.\n\n# Automatically Trigger Postmortem Debugging\n\nWhen a function misbehaves, the standard advice is to call `debug` on it and run the problematic call. That will enter the browser in the first line of the function, allowing you to (hoperfully) step through and track down the error.\n\nBut this can be automated. The `error` option allows you to set an error handler - a function that is called whenever R experiences an error. If you run\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptions(error = utils::recover)\n```\n:::\n\n\nthen R will trigger the debugger whenever it encounters an error (so long as it's an interactive session).\nThat will allow you to inspect the state of the function that caused the error right before it occurred, and any other frames on the call stack at that moment. R's error messages are often inscrutable, so this technique is quite powerful.\n\nHere's what it looks like in practice. Try running this line yourself and see if you can\npinpoint the subtle problem with it (though you can also guess it from `ave`'s signature).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nave(mtcars$mpg, mtcars$vs, mean)\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in unique.default(x, nmax = nmax): unique() applies only to vectors\n```\n:::\n:::\n\n\nThe traceback hints that the problem lies with the `...`, and inspecting the stack\nframes should be enough to track it down.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nError in unique.default(x, nmax = nmax) :\n  unique() applies only to vectors\n\nEnter a frame number, or 0 to exit\n\n1: ave(mtcars$mpg, mtcars$vs, mean)\n2: interaction(...)\n3: as.factor(args[[i]])\n4: factor(x)\n5: unique(x, nmax = nmax)\n6: unique.default(x, nmax = nmax)\n\nSelection:\n```\n:::\n\nOf course, this can become annoying when it happens for a trivial error like\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlm(mpg ~ cyll + wt, data = mtcars)\n```\n\n::: {.cell-output .cell-output-error}\n```\n-- Error in eval(predvars, data, env): object 'cyll' not found\n```\n:::\n:::\n\n\nbut in that case, you can simply set .\n\n## Get the Expressions Passed as Function Arguments\n\nR passes function arguments by value, not by reference, yet it's possible to recover\nthe symbol or expression passed to a function using this trick:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n  x <- deparse(substitute(x))\n  print(x)\n}\nf(`I'm a symbol!`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-- [1] \"I'm a symbol!\"\n```\n:::\n:::\n\n`substitute`, when called in a function, replaces its argument with the expression\nin the promise corresponding to that argument. (Promises are internal objects that implement function arguments). `deparse`\nconverts that unevaluated R code into a character vector.\n\nThis could be used to\nmake a function that\nautomatically labels\nplot axes:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndescriptive_plot <- function(x, y) {\n  x_name <- deparse(substitute(x))\n  y_name <- deparse(substitute(y))\n  plot(x, y, xlab = x_name, ylab = y_name)\n}\nweight <- mtcars$wt\nmpg <- mtcars$mpg\ndescriptive_plot(mpg, weight)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nWhat are your favorite R tricks?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}